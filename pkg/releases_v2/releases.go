package releasesv2

import (
	"encoding/json"
	"fmt"
	"os"
	"path"
	"regexp"
	"strings"

	"github.com/speakeasy-api/sdk-generation-action/internal/environment"
	"github.com/speakeasy-api/sdk-generation-action/internal/logging"
	"github.com/speakeasy-api/sdk-generation-action/internal/versionbumps"
	"github.com/speakeasy-api/sdk-generation-action/pkg/releases"
)

const speakeasyUrl = "https://speakeasy.com"
const speakeasyReleasesUrl = "https://github.com/speakeasy-api/speakeasy/releases"

// This representation is used when adding body to Github releases
func releaseContent(releaseInfo releases.ReleasesInfo, languagesChangelogMap map[string]string) string {

	releasesInformation := []string{}

	releaseInformation, err := json.MarshalIndent(releaseInfo, "", "  ")
	if err != nil {
		logging.Debug("Unable to marshal release info. Error: %s", err)
	} else {
		logging.Debug("releaseInfo : %s\n", releaseInformation)
	}

	releaseLangKeys := releases.SortedLangKeys(releaseInfo.Languages)
	languageChosenForChangelog := ""

	var releasesIsAList bool

	releaseLanguage := ""
	if len(releaseLangKeys) > 1 {
		releasesIsAList = true
	} else if len(releaseLangKeys) == 1 {
		releasesIsAList = false
		releaseLanguage = releaseLangKeys[0]
		languageChosenForChangelog = releaseLanguage
	} else {
		releasesIsAList = false
	}
	for _, lang := range releaseLangKeys {
		info := releaseInfo.Languages[lang]
		pkgID := ""
		pkgURL := ""
		switch lang {
		case "go":
			pkgID = "Go"
			repoPath := os.Getenv("GITHUB_REPOSITORY")
			tag := fmt.Sprintf("v%s", info.Version)
			if info.Path != "." {
				tag = fmt.Sprintf("%s/%s", info.Path, tag)
			}

			pkgURL = fmt.Sprintf("https://github.com/%s/releases/tag/%s", repoPath, tag)
		case "typescript":
			pkgID = "npm"
			pkgURL = fmt.Sprintf("https://www.npmjs.com/package/%s/v/%s", info.PackageName, info.Version)
		case "python":
			pkgID = "PyPI"
			pkgURL = fmt.Sprintf("https://pypi.org/project/%s/%s", info.PackageName, info.Version)
		case "php":
			pkgID = "Composer"
			pkgURL = fmt.Sprintf("https://packagist.org/packages/%s#v%s", info.PackageName, info.Version)
		case "terraform":
			pkgID = "Terraform"
			pkgURL = fmt.Sprintf("https://registry.terraform.io/providers/%s/%s", info.PackageName, info.Version)
		case "java":
			pkgID = "Maven Central"
			lastDotIndex := strings.LastIndex(info.PackageName, ".")
			groupID := info.PackageName[:lastDotIndex]      // everything before last occurrence of '.'
			artifactID := info.PackageName[lastDotIndex+1:] // everything after last occurrence of '.'
			pkgURL = fmt.Sprintf("https://central.sonatype.com/artifact/%s/%s/%s", groupID, artifactID, info.Version)
		case "ruby":
			pkgID = "Ruby Gems"
			pkgURL = fmt.Sprintf("https://rubygems.org/gems/%s/versions/%s", info.PackageName, info.Version)
		case "csharp":
			pkgID = "NuGet"
			pkgURL = fmt.Sprintf("https://www.nuget.org/packages/%s/%s", info.PackageName, info.Version)
		case "swift":
			pkgID = "Swift Package Manager"
			repoPath := os.Getenv("GITHUB_REPOSITORY")

			tag := fmt.Sprintf("v%s", info.Version)
			if info.Path != "." {
				tag = fmt.Sprintf("%s/%s", info.Path, tag)
			}

			pkgURL = fmt.Sprintf("https://github.com/%s/releases/tag/%s", repoPath, tag)
		}

		if pkgID != "" {
			if releasesIsAList {
				releasesInformation = append(releasesInformation, fmt.Sprintf("- [%s v%s] %s - %s", pkgID, info.Version, pkgURL, info.Path))
				languageChosenForChangelog = lang
			} else {
				releasesInformation = append(releasesInformation, fmt.Sprintf("[%s %s v%s](%s) - %s", pkgID, info.PackageName, info.Version, pkgURL, info.Path))
			}
		}
	}

	if releasesIsAList {
		releasesInformation = append([]string{"\n### Releases"}, releasesInformation...)
	}

	releaseTitle := releaseInfo.ReleaseTitle
	if !releasesIsAList {
		releaseTitle = fmt.Sprintf("%s v%s", releaseInfo.Languages[releaseLanguage].PackageName, releaseInfo.Languages[releaseLanguage].Version)

	}
	releaseFootNote := fmt.Sprintf("Generated by [Speakeasy](%s) [CLI %s](%s)", speakeasyUrl, releaseInfo.SpeakeasyVersion, speakeasyReleasesUrl)

	generatorChanges := languagesChangelogMap[languageChosenForChangelog]

	var builder strings.Builder

	// Start with header
	builder.WriteString("\n\n## ")
	builder.WriteString(releaseTitle)
	builder.WriteString("\n")

	if len(releasesInformation) > 0 {
		builder.WriteString(strings.Join(releasesInformation, "\n"))
		builder.WriteString("\n")
	}
	if generatorChanges != "" {
		builder.WriteString(generatorChanges)
	}

	if releaseFootNote != "" {
		// foot note separator
		builder.WriteString("\t\n")
		builder.WriteString(releaseFootNote)
	}
	logging.Debug("Full Sdk Changelog is : %v\n", builder.String())

	return builder.String()
}

func UpdateReleasesFile(releaseInfo releases.ReleasesInfo, dir string, versioningInfo versionbumps.VersioningInfo) error {
	releasesPath := GetReleasesPath(dir)

	logging.Debug("Updating releases file at %s", releasesPath)
	f, err := os.OpenFile(releasesPath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0o600)
	if err != nil {
		logging.Debug("error while opening file: %s", err.Error())
		return fmt.Errorf("error opening releases file: %w", err)
	}
	defer f.Close()

	releaseLangKeys := releases.SortedLangKeys(releaseInfo.Languages)
	languagesChangelogMap := make(map[string]string)
	if versioningInfo.VersionReport != nil {
		reports := versioningInfo.VersionReport.Reports
		for _, lang := range releaseLangKeys {
			key := fmt.Sprintf("SDK_CHANGELOG_%s", strings.ToLower(lang))
			sdkChangelog := releases.FindPRReportByKey(reports, key)
			if sdkChangelog != "" {
				languagesChangelogMap[lang] = sdkChangelog
			}
		}
	}
	finalReleaseInfo := releaseContent(releaseInfo, languagesChangelogMap)

	logging.Debug("releaseInfo is: %s", finalReleaseInfo)
	bytesWritten, err := f.WriteString(finalReleaseInfo)
	logging.Debug("Successfully updated releases file at  %s. Number of bytes written: %d", releasesPath, bytesWritten)
	if err != nil {
		logging.Debug("error while writing to file: %s", err.Error())
		return fmt.Errorf("error writing to releases file: %w", err)
	}

	return nil
}

var (
	releaseInfoRegex        = regexp.MustCompile(`(?s)## (.*?)\n### Changes\n(.*?)Based on:\n- OpenAPI Doc (.*?) (.*?)\n- Speakeasy CLI (.*?) (\((.*?)\))?.*?`)
	generatedLanguagesRegex = regexp.MustCompile(`- \[([a-z]+) v(\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)] (.*)`)
	langHeaderRegex         = regexp.MustCompile(`(?m)^## ([^\s]+) SDK Changes Detected:`)
	npmReleaseRegex         = regexp.MustCompile(`\[npm (.*?) v(\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)\]\((https:\/\/www\.npmjs\.com\/package\/.*?\/v\/\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)\) - (.*)`)
	pypiReleaseRegex        = regexp.MustCompile(`\[PyPI (.*?) v(\d+\.\d+\.\d+(?:-?\w+(?:\.\w+)*)?)\]\((https:\/\/pypi\.org\/project\/.*?\/\d+\.\d+\.\d+(?:-?\w+(?:\.\w+)*)?)\) - (.*)`)
	goReleaseRegex          = regexp.MustCompile(`\[Go (.*?) v(\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)\]\((https?:\/\/[^\)]+)\) - ([^#]*)`)
	composerReleaseRegex    = regexp.MustCompile(`\[Composer (.*?) v(\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)\]\((https:\/\/packagist\.org\/packages\/.*?#v\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)\) - (.*)`)
	mavenReleaseRegex       = regexp.MustCompile(`\[Maven Central (.*?) v(\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)\]\((https:\/\/central\.sonatype\.com\/artifact\/.*?)\) - (.*)`)
	rubyGemReleaseRegex     = regexp.MustCompile(`\[Ruby Gems (.*?) v(\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)\]\((https:\/\/rubygems\.org\/gems\/.*?\/versions\/.*?)\) - (.*)`)
	nugetReleaseRegex       = regexp.MustCompile(`\[NuGet (.*?) v(\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)\]\((https:\/\/www\.nuget\.org\/packages\/.*?)\) - (.*)`)
	swiftReleaseRegex       = regexp.MustCompile(`\[Swift Package Manager (.*?) v(\d+\.\d+\.\d+(?:-\w+(?:\.\w+)*)?)\]\((https:\/\/github\.com\/.*?\/releases\/tag\/.*?)\) - (.*)`)
)

func GetLastReleaseInfo(dir string) (map[string]releases.LanguageReleaseInfo, string, error) {
	releasesPath := GetReleasesPath(dir)

	logging.Debug("Reading releases file at %s", releasesPath)

	data, err := os.ReadFile(releasesPath)
	if err != nil {
		return nil, "", fmt.Errorf("error reading releases file: %w", err)
	}

	return ParseReleasesV2(string(data))
}

func ParseReleasesV2(data string) (map[string]releases.LanguageReleaseInfo, string, error) {
	releaseEntries := strings.Split(data, "\n\n")

	if len(releaseEntries) == 0 {
		return nil, "", fmt.Errorf("no releases found")
	}

	// Find the entry that contains release information (starts with ##)
	lastRelease := ""
	lastRelease = releaseEntries[len(releaseEntries)-1]

	if lastRelease == "" {
		return nil, "", fmt.Errorf("no release header found")
	}

	releaseContent := strings.TrimSuffix(ensureLeadingNewlines(lastRelease), "\n")

	// Parse languages from the target release
	languages := make(map[string]releases.LanguageReleaseInfo)

	// Parse NPM/TypeScript releases
	npmMatches := npmReleaseRegex.FindStringSubmatch(lastRelease)
	if len(npmMatches) == 5 {
		languages["typescript"] = releases.LanguageReleaseInfo{
			PackageName: npmMatches[1],
			Version:     npmMatches[2],
			URL:         npmMatches[3],
			Path:        npmMatches[4],
		}
	}

	// Parse PyPI/Python releases
	pypiMatches := pypiReleaseRegex.FindStringSubmatch(lastRelease)
	if len(pypiMatches) == 5 {
		languages["python"] = releases.LanguageReleaseInfo{
			PackageName: pypiMatches[1],
			Version:     pypiMatches[2],
			URL:         pypiMatches[3],
			Path:        pypiMatches[4],
		}
	}

	// Parse Go releases
	goMatches := goReleaseRegex.FindStringSubmatch(lastRelease)
	if len(goMatches) == 5 {
		packageName := goMatches[1]
		path := strings.TrimSpace(goMatches[4])

		if path != "." {
			packageName = fmt.Sprintf("%s/%s", packageName, strings.TrimPrefix(path, "./"))
		}

		languages["go"] = releases.LanguageReleaseInfo{
			PackageName: packageName,
			Version:     goMatches[2],
			URL:         goMatches[3],
			Path:        path,
		}
	}

	// Parse Composer/PHP releases
	composerMatches := composerReleaseRegex.FindStringSubmatch(lastRelease)
	if len(composerMatches) == 5 {
		languages["php"] = releases.LanguageReleaseInfo{
			PackageName: composerMatches[1],
			Version:     composerMatches[2],
			URL:         composerMatches[3],
			Path:        composerMatches[4],
		}
	}

	// Parse Maven/Java releases
	mavenMatches := mavenReleaseRegex.FindStringSubmatch(lastRelease)
	if len(mavenMatches) == 5 {
		languages["java"] = releases.LanguageReleaseInfo{
			PackageName: mavenMatches[1],
			Version:     mavenMatches[2],
			URL:         mavenMatches[3],
			Path:        mavenMatches[4],
		}
	}

	// Parse Ruby Gems releases
	rubyGemsMatches := rubyGemReleaseRegex.FindStringSubmatch(lastRelease)
	if len(rubyGemsMatches) == 5 {
		languages["ruby"] = releases.LanguageReleaseInfo{
			PackageName: rubyGemsMatches[1],
			Version:     rubyGemsMatches[2],
			URL:         rubyGemsMatches[3],
			Path:        rubyGemsMatches[4],
		}
	}

	// Parse NuGet/C# releases
	nugetMatches := nugetReleaseRegex.FindStringSubmatch(lastRelease)
	if len(nugetMatches) == 5 {
		languages["csharp"] = releases.LanguageReleaseInfo{
			PackageName: nugetMatches[1],
			Version:     nugetMatches[2],
			URL:         nugetMatches[3],
			Path:        nugetMatches[4],
		}
	}

	// Parse Swift Package Manager releases
	swiftMatches := swiftReleaseRegex.FindStringSubmatch(lastRelease)
	if len(swiftMatches) == 5 {
		packageName := swiftMatches[1]
		path := swiftMatches[4]

		if path != "." {
			packageName = fmt.Sprintf("%s/%s", packageName, strings.TrimPrefix(path, "./"))
		}

		languages["swift"] = releases.LanguageReleaseInfo{
			PackageName: packageName,
			Version:     swiftMatches[2],
			URL:         swiftMatches[3],
			Path:        path,
		}
	}

	return languages, releaseContent, nil
}

// ensureLeadingNewlines ensures the content starts with \n\n for consistent formatting
func ensureLeadingNewlines(content string) string {
	if strings.HasPrefix(content, "\n\n") {
		return content
	}
	return "\n\n" + content
}

func GetReleasesPath(dir string) string {
	return path.Join(environment.GetWorkspace(), "repo", dir, "RELEASES.md")
}
