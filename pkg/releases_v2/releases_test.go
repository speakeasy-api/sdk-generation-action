package releasesv2

import (
	"os"
	"reflect"
	"testing"

	releases "github.com/speakeasy-api/sdk-generation-action/pkg/releases"
)

func Test_ParseReleasesV2(t *testing.T) {
	// Set environment variable for proper URL generation
	os.Setenv("GITHUB_REPOSITORY", "speakeasy-api/sdk-gen-go")
	releaseInfo := releases.ReleasesInfo{
		ReleaseTitle:      "2025-06-24 19:00:10",
		DocVersion:        "",
		DocLocation:       "",
		SpeakeasyVersion:  "0.0.1",
		GenerationVersion: "2.623.3",
		Languages: map[string]releases.LanguageReleaseInfo{
			"go": {
				PackageName:     "@vercel/sdk",
				Path:            ".",
				Version:         "0.1.0",
				PreviousVersion: "", // ParseReleasesV2 doesn't extract previous version info
				URL:             "https://github.com/speakeasy-api/sdk-gen-go/releases/tag/v0.1.0",
			},
		},
		LanguagesGenerated: map[string]releases.GenerationInfo{
			"go": {Version: "0.1.0", Path: "."},
		},
		LanguageChangelog: map[string]string{},
	}
	languageChangelog :=
		map[string]string{
			"go": "## Go SDK Changes Detected:\n* Sdk.Api.V1.Users.Profile.Settings.UpdateAppearance(): **Added**\n* Sdk.Api.V1.Users.Profile.Settings.GetPrivacy(): **Added** request.Request\n* Sdk.Api.V1.Users.Profile.Settings.GetNotifications(): **Deprecated**\n",
		}

	content := releaseContent(releaseInfo, languageChangelog)

	languageInfo, parsedContent, err := ParseReleasesV2(content)
	// err should be nil
	if err != nil {
		t.Errorf("Error parsing releases v2: %v", err)
	}
	// languageInfo should be the same as releaseInfo.Languages
	if !reflect.DeepEqual(languageInfo, releaseInfo.Languages) {
		t.Errorf("Language info did not match after conversion")
		t.Errorf("Expected: %+v", releaseInfo.Languages)
		t.Errorf("Actual: %+v", languageInfo)
	}

	// Verify that parsedContent contains the expected release content
	if parsedContent == "" {
		t.Errorf("ParsedContent should not be empty")
	}
	expectedContent := `

## @vercel/sdk v0.1.0
[Go @vercel/sdk v0.1.0](https://github.com/speakeasy-api/sdk-gen-go/releases/tag/v0.1.0) - .
## Go SDK Changes Detected:
* Sdk.Api.V1.Users.Profile.Settings.UpdateAppearance(): **Added**
* Sdk.Api.V1.Users.Profile.Settings.GetPrivacy(): **Added** request.Request
* Sdk.Api.V1.Users.Profile.Settings.GetNotifications(): **Deprecated**

Generated by [Speakeasy](https://speakeasy.com) [CLI 0.0.1](https://github.com/speakeasy-api/speakeasy/releases)
`
	if parsedContent != expectedContent {
		t.Errorf("ParsedContent did not match expected content")
		t.Errorf("***Expected***:\n%q\n", expectedContent)
		t.Errorf("***Actual***:\n%q\n", parsedContent)
	}
}

func Test_ParseReleasesV2_TypeScript(t *testing.T) {
	// Set environment variable for proper URL generation
	os.Setenv("GITHUB_REPOSITORY", "speakeasy-api/typescript-sdk")
	releaseInfo := releases.ReleasesInfo{
		ReleaseTitle:      "2025-06-24 19:00:10",
		DocVersion:        "",
		DocLocation:       "",
		SpeakeasyVersion:  "0.0.1",
		GenerationVersion: "2.623.3",
		Languages: map[string]releases.LanguageReleaseInfo{
			"typescript": {
				PackageName:     "@acme/typescript-sdk",
				Path:            ".",
				Version:         "1.2.0",
				PreviousVersion: "", // ParseReleasesV2 doesn't extract previous version info
				URL:             "https://www.npmjs.com/package/@acme/typescript-sdk/v/1.2.0",
			},
		},
		LanguagesGenerated: map[string]releases.GenerationInfo{
			"typescript": {Version: "1.2.0", Path: "."},
		},
		LanguageChangelog: map[string]string{},
	}
	languageChangelog := map[string]string{
		"typescript": "## TypeScript SDK Changes Detected:\n* Api.Users.Profile.UpdateSettings(): **Added**\n* Api.Users.Profile.GetProfile(): **Modified** - Added new field\n",
	}

	content := releaseContent(releaseInfo, languageChangelog)
	
	languageInfo, parsedContent, err := ParseReleasesV2(content)
	// err should be nil
	if err != nil {
		t.Errorf("Error parsing releases v2: %v", err)
	}
	// languageInfo should be the same as releaseInfo.Languages
	if !reflect.DeepEqual(languageInfo, releaseInfo.Languages) {
		t.Errorf("Language info did not match after conversion")
		t.Errorf("Expected: %+v", releaseInfo.Languages)
		t.Errorf("Actual: %+v", languageInfo)
	}
	
	// Verify that parsedContent contains the expected release content
	if parsedContent == "" {
		t.Errorf("ParsedContent should not be empty")
	}
	expectedContent := `

## @acme/typescript-sdk v1.2.0
[npm @acme/typescript-sdk v1.2.0](https://www.npmjs.com/package/@acme/typescript-sdk/v/1.2.0) - .
## TypeScript SDK Changes Detected:
* Api.Users.Profile.UpdateSettings(): **Added**
* Api.Users.Profile.GetProfile(): **Modified** - Added new field

Generated by [Speakeasy](https://speakeasy.com) [CLI 0.0.1](https://github.com/speakeasy-api/speakeasy/releases)
`
	if parsedContent != expectedContent {
		t.Errorf("ParsedContent did not match expected content")
		t.Errorf("***Expected***:\n%q\n", expectedContent)
		t.Errorf("***Actual***:\n%q\n", parsedContent)
	}
}

func Test_ParseReleasesV2_Python(t *testing.T) {
	// Set environment variable for proper URL generation
	os.Setenv("GITHUB_REPOSITORY", "speakeasy-api/python-sdk")
	releaseInfo := releases.ReleasesInfo{
		ReleaseTitle:      "2025-06-24 19:00:10",
		DocVersion:        "",
		DocLocation:       "",
		SpeakeasyVersion:  "0.0.1",
		GenerationVersion: "2.623.3",
		Languages: map[string]releases.LanguageReleaseInfo{
			"python": {
				PackageName:     "acme-python-sdk",
				Path:            ".",
				Version:         "2.1.5",
				PreviousVersion: "", // ParseReleasesV2 doesn't extract previous version info
				URL:             "https://pypi.org/project/acme-python-sdk/2.1.5",
			},
		},
		LanguagesGenerated: map[string]releases.GenerationInfo{
			"python": {Version: "2.1.5", Path: "."},
		},
		LanguageChangelog: map[string]string{},
	}
	languageChangelog := map[string]string{
		"python": "## Python SDK Changes Detected:\n* client.api.users.create_user(): **Added**\n* client.api.users.delete_user(): **Deprecated**\n",
	}

	content := releaseContent(releaseInfo, languageChangelog)
	
	languageInfo, parsedContent, err := ParseReleasesV2(content)
	// err should be nil
	if err != nil {
		t.Errorf("Error parsing releases v2: %v", err)
	}
	// languageInfo should be the same as releaseInfo.Languages
	if !reflect.DeepEqual(languageInfo, releaseInfo.Languages) {
		t.Errorf("Language info did not match after conversion")
		t.Errorf("Expected: %+v", releaseInfo.Languages)
		t.Errorf("Actual: %+v", languageInfo)
	}
	
	// Verify that parsedContent contains the expected release content
	if parsedContent == "" {
		t.Errorf("ParsedContent should not be empty")
	}
	expectedContent := `

## acme-python-sdk v2.1.5
[PyPI acme-python-sdk v2.1.5](https://pypi.org/project/acme-python-sdk/2.1.5) - .
## Python SDK Changes Detected:
* client.api.users.create_user(): **Added**
* client.api.users.delete_user(): **Deprecated**

Generated by [Speakeasy](https://speakeasy.com) [CLI 0.0.1](https://github.com/speakeasy-api/speakeasy/releases)
`
	if parsedContent != expectedContent {
		t.Errorf("ParsedContent did not match expected content")
		t.Errorf("***Expected***:\n%q\n", expectedContent)
		t.Errorf("***Actual***:\n%q\n", parsedContent)
	}
}

func Test_ParseReleasesV2_Java(t *testing.T) {
	// Set environment variable for proper URL generation
	os.Setenv("GITHUB_REPOSITORY", "speakeasy-api/java-sdk")
	releaseInfo := releases.ReleasesInfo{
		ReleaseTitle:      "2025-06-24 19:00:10",
		DocVersion:        "",
		DocLocation:       "",
		SpeakeasyVersion:  "0.0.1",
		GenerationVersion: "2.623.3",
		Languages: map[string]releases.LanguageReleaseInfo{
			"java": {
				PackageName:     "com.acme.javasdk",
				Path:            ".",
				Version:         "3.0.2",
				PreviousVersion: "", // ParseReleasesV2 doesn't extract previous version info
				URL:             "https://central.sonatype.com/artifact/com.acme/javasdk/3.0.2",
			},
		},
		LanguagesGenerated: map[string]releases.GenerationInfo{
			"java": {Version: "3.0.2", Path: "."},
		},
		LanguageChangelog: map[string]string{},
	}
	languageChangelog := map[string]string{
		"java": "## Java SDK Changes Detected:\n* SDK.api().users().profile().updateSettings(): **Added**\n* SDK.api().users().profile().getSettings(): **Modified**\n",
	}

	content := releaseContent(releaseInfo, languageChangelog)
	
	languageInfo, parsedContent, err := ParseReleasesV2(content)
	// err should be nil
	if err != nil {
		t.Errorf("Error parsing releases v2: %v", err)
	}
	// languageInfo should be the same as releaseInfo.Languages
	if !reflect.DeepEqual(languageInfo, releaseInfo.Languages) {
		t.Errorf("Language info did not match after conversion")
		t.Errorf("Expected: %+v", releaseInfo.Languages)
		t.Errorf("Actual: %+v", languageInfo)
	}
	
	// Verify that parsedContent contains the expected release content
	if parsedContent == "" {
		t.Errorf("ParsedContent should not be empty")
	}
	expectedContent := `

## com.acme.javasdk v3.0.2
[Maven Central com.acme.javasdk v3.0.2](https://central.sonatype.com/artifact/com.acme/javasdk/3.0.2) - .
## Java SDK Changes Detected:
* SDK.api().users().profile().updateSettings(): **Added**
* SDK.api().users().profile().getSettings(): **Modified**

Generated by [Speakeasy](https://speakeasy.com) [CLI 0.0.1](https://github.com/speakeasy-api/speakeasy/releases)
`
	if parsedContent != expectedContent {
		t.Errorf("ParsedContent did not match expected content")
		t.Errorf("***Expected***:\n%q\n", expectedContent)
		t.Errorf("***Actual***:\n%q\n", parsedContent)
	}
}

func Test_ParseReleasesV2_CSharp(t *testing.T) {
	// Set environment variable for proper URL generation
	os.Setenv("GITHUB_REPOSITORY", "speakeasy-api/csharp-sdk")
	releaseInfo := releases.ReleasesInfo{
		ReleaseTitle:      "2025-06-24 19:00:10",
		DocVersion:        "",
		DocLocation:       "",
		SpeakeasyVersion:  "0.0.1",
		GenerationVersion: "2.623.3",
		Languages: map[string]releases.LanguageReleaseInfo{
			"csharp": {
				PackageName:     "Acme.CSharpSDK",
				Path:            ".",
				Version:         "4.1.3",
				PreviousVersion: "", // ParseReleasesV2 doesn't extract previous version info
				URL:             "https://www.nuget.org/packages/Acme.CSharpSDK/4.1.3",
			},
		},
		LanguagesGenerated: map[string]releases.GenerationInfo{
			"csharp": {Version: "4.1.3", Path: "."},
		},
		LanguageChangelog: map[string]string{},
	}
	languageChangelog := map[string]string{
		"csharp": "## C# SDK Changes Detected:\n* SDK.Api.Users.Profile.UpdateSettingsAsync(): **Added**\n* SDK.Api.Users.Profile.GetProfileAsync(): **Modified**\n",
	}

	content := releaseContent(releaseInfo, languageChangelog)
	
	languageInfo, parsedContent, err := ParseReleasesV2(content)
	// err should be nil
	if err != nil {
		t.Errorf("Error parsing releases v2: %v", err)
	}
	// languageInfo should be the same as releaseInfo.Languages
	if !reflect.DeepEqual(languageInfo, releaseInfo.Languages) {
		t.Errorf("Language info did not match after conversion")
		t.Errorf("Expected: %+v", releaseInfo.Languages)
		t.Errorf("Actual: %+v", languageInfo)
	}
	
	// Verify that parsedContent contains the expected release content
	if parsedContent == "" {
		t.Errorf("ParsedContent should not be empty")
	}
	expectedContent := `

## Acme.CSharpSDK v4.1.3
[NuGet Acme.CSharpSDK v4.1.3](https://www.nuget.org/packages/Acme.CSharpSDK/4.1.3) - .
## C# SDK Changes Detected:
* SDK.Api.Users.Profile.UpdateSettingsAsync(): **Added**
* SDK.Api.Users.Profile.GetProfileAsync(): **Modified**

Generated by [Speakeasy](https://speakeasy.com) [CLI 0.0.1](https://github.com/speakeasy-api/speakeasy/releases)
`
	if parsedContent != expectedContent {
		t.Errorf("ParsedContent did not match expected content")
		t.Errorf("***Expected***:\n%q\n", expectedContent)
		t.Errorf("***Actual***:\n%q\n", parsedContent)
	}
}

func Test_ParseReleasesV2_PHP(t *testing.T) {
	// Set environment variable for proper URL generation
	os.Setenv("GITHUB_REPOSITORY", "speakeasy-api/php-sdk")
	releaseInfo := releases.ReleasesInfo{
		ReleaseTitle:      "2025-06-24 19:00:10",
		DocVersion:        "",
		DocLocation:       "",
		SpeakeasyVersion:  "0.0.1",
		GenerationVersion: "2.623.3",
		Languages: map[string]releases.LanguageReleaseInfo{
			"php": {
				PackageName:     "acme/php-sdk",
				Path:            ".",
				Version:         "5.2.1",
				PreviousVersion: "", // ParseReleasesV2 doesn't extract previous version info
				URL:             "https://packagist.org/packages/acme/php-sdk#v5.2.1",
			},
		},
		LanguagesGenerated: map[string]releases.GenerationInfo{
			"php": {Version: "5.2.1", Path: "."},
		},
		LanguageChangelog: map[string]string{},
	}
	languageChangelog := map[string]string{
		"php": "## PHP SDK Changes Detected:\n* $sdk->api->users->profile->updateSettings(): **Added**\n* $sdk->api->users->profile->getProfile(): **Modified**\n",
	}

	content := releaseContent(releaseInfo, languageChangelog)
	
	languageInfo, parsedContent, err := ParseReleasesV2(content)
	// err should be nil
	if err != nil {
		t.Errorf("Error parsing releases v2: %v", err)
	}
	// languageInfo should be the same as releaseInfo.Languages
	if !reflect.DeepEqual(languageInfo, releaseInfo.Languages) {
		t.Errorf("Language info did not match after conversion")
		t.Errorf("Expected: %+v", releaseInfo.Languages)
		t.Errorf("Actual: %+v", languageInfo)
	}
	
	// Verify that parsedContent contains the expected release content
	if parsedContent == "" {
		t.Errorf("ParsedContent should not be empty")
	}
	expectedContent := `

## acme/php-sdk v5.2.1
[Composer acme/php-sdk v5.2.1](https://packagist.org/packages/acme/php-sdk#v5.2.1) - .
## PHP SDK Changes Detected:
* $sdk->api->users->profile->updateSettings(): **Added**
* $sdk->api->users->profile->getProfile(): **Modified**

Generated by [Speakeasy](https://speakeasy.com) [CLI 0.0.1](https://github.com/speakeasy-api/speakeasy/releases)
`
	if parsedContent != expectedContent {
		t.Errorf("ParsedContent did not match expected content")
		t.Errorf("***Expected***:\n%q\n", expectedContent)
		t.Errorf("***Actual***:\n%q\n", parsedContent)
	}
}

func Test_ParseReleasesV2_Ruby(t *testing.T) {
	// Set environment variable for proper URL generation
	os.Setenv("GITHUB_REPOSITORY", "speakeasy-api/ruby-sdk")
	releaseInfo := releases.ReleasesInfo{
		ReleaseTitle:      "2025-06-24 19:00:10",
		DocVersion:        "",
		DocLocation:       "",
		SpeakeasyVersion:  "0.0.1",
		GenerationVersion: "2.623.3",
		Languages: map[string]releases.LanguageReleaseInfo{
			"ruby": {
				PackageName:     "acme-ruby-sdk",
				Path:            ".",
				Version:         "6.0.4",
				PreviousVersion: "", // ParseReleasesV2 doesn't extract previous version info
				URL:             "https://rubygems.org/gems/acme-ruby-sdk/versions/6.0.4",
			},
		},
		LanguagesGenerated: map[string]releases.GenerationInfo{
			"ruby": {Version: "6.0.4", Path: "."},
		},
		LanguageChangelog: map[string]string{},
	}
	languageChangelog := map[string]string{
		"ruby": "## Ruby SDK Changes Detected:\n* sdk.api.users.profile.update_settings(): **Added**\n* sdk.api.users.profile.get_profile(): **Modified**\n",
	}

	content := releaseContent(releaseInfo, languageChangelog)
	
	languageInfo, parsedContent, err := ParseReleasesV2(content)
	// err should be nil
	if err != nil {
		t.Errorf("Error parsing releases v2: %v", err)
	}
	// languageInfo should be the same as releaseInfo.Languages
	if !reflect.DeepEqual(languageInfo, releaseInfo.Languages) {
		t.Errorf("Language info did not match after conversion")
		t.Errorf("Expected: %+v", releaseInfo.Languages)
		t.Errorf("Actual: %+v", languageInfo)
	}
	
	// Verify that parsedContent contains the expected release content
	if parsedContent == "" {
		t.Errorf("ParsedContent should not be empty")
	}
	expectedContent := `

## acme-ruby-sdk v6.0.4
[Ruby Gems acme-ruby-sdk v6.0.4](https://rubygems.org/gems/acme-ruby-sdk/versions/6.0.4) - .
## Ruby SDK Changes Detected:
* sdk.api.users.profile.update_settings(): **Added**
* sdk.api.users.profile.get_profile(): **Modified**

Generated by [Speakeasy](https://speakeasy.com) [CLI 0.0.1](https://github.com/speakeasy-api/speakeasy/releases)
`
	if parsedContent != expectedContent {
		t.Errorf("ParsedContent did not match expected content")
		t.Errorf("***Expected***:\n%q\n", expectedContent)
		t.Errorf("***Actual***:\n%q\n", parsedContent)
	}
}

func Test_ParseReleasesV2_Swift(t *testing.T) {
	// Set environment variable for proper URL generation
	os.Setenv("GITHUB_REPOSITORY", "speakeasy-api/swift-sdk")
	releaseInfo := releases.ReleasesInfo{
		ReleaseTitle:      "2025-06-24 19:00:10",
		DocVersion:        "",
		DocLocation:       "",
		SpeakeasyVersion:  "0.0.1",
		GenerationVersion: "2.623.3",
		Languages: map[string]releases.LanguageReleaseInfo{
			"swift": {
				PackageName:     "speakeasy-api/swift-sdk",
				Path:            ".",
				Version:         "7.1.2",
				PreviousVersion: "", // ParseReleasesV2 doesn't extract previous version info
				URL:             "https://github.com/speakeasy-api/swift-sdk/releases/tag/v7.1.2",
			},
		},
		LanguagesGenerated: map[string]releases.GenerationInfo{
			"swift": {Version: "7.1.2", Path: "."},
		},
		LanguageChangelog: map[string]string{},
	}
	languageChangelog := map[string]string{
		"swift": "## Swift SDK Changes Detected:\n* SDK.api.users.profile.updateSettings(): **Added**\n* SDK.api.users.profile.getProfile(): **Modified**\n",
	}

	content := releaseContent(releaseInfo, languageChangelog)
	
	languageInfo, parsedContent, err := ParseReleasesV2(content)
	// err should be nil
	if err != nil {
		t.Errorf("Error parsing releases v2: %v", err)
	}
	// languageInfo should be the same as releaseInfo.Languages
	if !reflect.DeepEqual(languageInfo, releaseInfo.Languages) {
		t.Errorf("Language info did not match after conversion")
		t.Errorf("Expected: %+v", releaseInfo.Languages)
		t.Errorf("Actual: %+v", languageInfo)
	}
	
	// Verify that parsedContent contains the expected release content
	if parsedContent == "" {
		t.Errorf("ParsedContent should not be empty")
	}
	expectedContent := `

## speakeasy-api/swift-sdk v7.1.2
[Swift Package Manager speakeasy-api/swift-sdk v7.1.2](https://github.com/speakeasy-api/swift-sdk/releases/tag/v7.1.2) - .
## Swift SDK Changes Detected:
* SDK.api.users.profile.updateSettings(): **Added**
* SDK.api.users.profile.getProfile(): **Modified**

Generated by [Speakeasy](https://speakeasy.com) [CLI 0.0.1](https://github.com/speakeasy-api/speakeasy/releases)
`
	if parsedContent != expectedContent {
		t.Errorf("ParsedContent did not match expected content")
		t.Errorf("***Expected***:\n%q\n", expectedContent)
		t.Errorf("***Actual***:\n%q\n", parsedContent)
	}
}

// func Test_AbleToParseReleasesFile(t *testing.T) {
// 	releasesFile := `

// ## @vercel/sdk v0.1.0
// [Go @vercel/sdk v0.1.0](https://github.com/speakeasy-api/sdk-gen-go/releases/tag/v0.1.0) - .
// ## Go SDK Changes Detected:
// * Sdk.Api.V1.Users.Profile.Settings.UpdateAppearance(): **Added**
// * Sdk.Api.V1.Users.Profile.Settings.GetPrivacy(): **Added** request.Request
// * Sdk.Api.V1.Users.Profile.Settings.GetNotifications(): **Deprecated**

// Generated by [Speakeasy](https://speakeasy.com) [CLI 0.0.1](https://github.com/speakeasy-api/speakeasy/releases)

// ## 2024-08-07 14:25:13
// ### Changes
// Based on:
// - OpenAPI Doc
// - Speakeasy CLI 1.356.0 (2.388.1) https://github.com/speakeasy-api/speakeasy
// ### Generated
// - [python v1.0.0] .
// ### Releases
// - [PyPI v1.0.0] https://pypi.org/project/mistralai/1.0.0 - .

// ## 2024-08-08 18:12:16
// ### Changes
// Based on:
// - OpenAPI Doc
// - Speakeasy CLI 1.357.4 (2.390.6) https://github.com/speakeasy-api/speakeasy
// ### Generated
// - [python v1.0.1] .
// ### Releases
// - [PyPI v1.0.1] https://pypi.org/project/mistralai/1.0.1 - .`

// 	languageInfo, parsedContent, err := ParseReleasesV2(releasesFile)
// 	if err != nil {
// 		t.Errorf("Error parsing releases v2: %v", err)
// 	}

// 	expectedLanguageInfo := map[string]releases.LanguageReleaseInfo{
// 		"go": {
// 			PackageName:     "@vercel/sdk",
// 			Path:            ".",
// 			Version:         "0.1.0",
// 			PreviousVersion: "", // ParseReleasesV2 doesn't extract previous version info
// 			URL:             "https://github.com/speakeasy-api/sdk-gen-go/releases/tag/v0.1.0",
// 		},
// 	}

// 	if languageInfo !=
// 	fmt.Print(" Parsed Content-----**-----")
// 	fmt.Print("\n")
// 	fmt.Println(parsedContent)
// 	fmt.Print(" Language Info-----**-----")
// 	fmt.Print("\n")
// 	fmt.Println(languageInfo)
// 	fmt.Print("-----**-----")
// 	fmt.Print("\n")
// }

// func TestConvertToV2_EmptyFields(t *testing.T) {
// 	v1 := releases.ReleasesInfo{
// 		ReleaseTitle:      "2025-06-24 19:00:10",
// 		DocVersion:        "",
// 		DocLocation:       "",
// 		SpeakeasyVersion:  "0.0.1",
// 		GenerationVersion: "2.623.3",
// 		Languages:         map[string]releases.LanguageReleaseInfo{},
// 		LanguagesGenerated: map[string]releases.GenerationInfo{
// 			"typescript": {Version: "0.1.0", Path: "."},
// 			"go":         {Version: "0.1.0", Path: "."},
// 		},
// 		LanguageChangelog: map[string]string{},
// 	}

// 	v2 := ConvertToV2(v1)

// 	if v2.ReleaseTitle != v1.ReleaseTitle || v2.DocVersion != v1.DocVersion || v2.DocLocation != v1.DocLocation || v2.SpeakeasyVersion != v1.SpeakeasyVersion || v2.GenerationVersion != v1.GenerationVersion {
// 		t.Errorf("Basic fields did not match after conversion")
// 	}

// 	// Compare Languages field by converting to expected V2 format
// 	expectedV2Languages := make(map[string]LanguageReleaseInfoV2)
// 	for lang, info := range v1.Languages {
// 		expectedV2Languages[lang] = LanguageReleaseInfoV2{
// 			PackageName:     info.PackageName,
// 			Path:            info.Path,
// 			Version:         info.Version,
// 			PreviousVersion: info.PreviousVersion,
// 			URL:             info.URL,
// 		}
// 	}
// 	if !reflect.DeepEqual(v2.Languages, expectedV2Languages) {
// 		t.Errorf("Languages field did not match after conversion.\nExpected: %+v\nActual: %+v", expectedV2Languages, v2.Languages)
// 	}

// 	// Compare LanguagesGenerated field by converting to expected V2 format
// 	expectedV2LanguagesGenerated := make(map[string]GenerationInfoV2)
// 	for lang, info := range v1.LanguagesGenerated {
// 		expectedV2LanguagesGenerated[lang] = GenerationInfoV2{
// 			Version: info.Version,
// 			Path:    info.Path,
// 		}
// 	}
// 	if !reflect.DeepEqual(v2.LanguagesGenerated, expectedV2LanguagesGenerated) {
// 		t.Errorf("LanguagesGenerated field did not match after conversion.\nExpected: %+v\nActual: %+v", expectedV2LanguagesGenerated, v2.LanguagesGenerated)
// 	}

// 	if !reflect.DeepEqual(v2.LanguageChangelog, v1.LanguageChangelog) {
// 		t.Errorf("LanguageChangelog field did not match after conversion")
// 	}
// }
